<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SLProject: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="SLProject.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SLProject
   &#160;<span id="projectnumber">3.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__introduction.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#overview">Overview</a></li>
<li class="level1"><a href="#diagram">Class Diagram</a></li>
<li class="level1"><a href="#app">Application Code</a></li>
<li class="level1"><a href="#central">Central Classes</a></li>
<li class="level1"><a href="#node">Scenegraph Classes</a></li>
<li class="level1"><a href="#mesh">Mesh Classes</a></li>
<li class="level1"><a href="#vao">VertexArray Classes</a></li>
<li class="level1"><a href="#material">Material Classes</a></li>
<li class="level1"><a href="#animation">Animation Classes</a></li>
<li class="level1"><a href="#imageprocessing">Image and Video Processing Classes</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="overview"></a>
Overview</h1>
<p>There are 5 code sections in an SLProject application: </p><ul>
<li>
<b>APP</b>: Application code: <ul>
<li>
OS dependent OpenGL context and window creation </li>
<li>
UI Definition using ImGUI </li>
<li>
Scene definition using SL </li>
<li>
Video processing using CV </li>
</ul>
</li>
<li>
<b>SL</b>: Scene Library code: <ul>
<li>
Scene &amp; Sceneview management </li>
<li>
Scenegraph classes </li>
<li>
3D and 2D rendering </li>
<li>
Animation </li>
</ul>
</li>
<li>
<b>CV</b>: Computer Vision code: <ul>
<li>
Video Capturing </li>
<li>
Calibration </li>
<li>
Tracking </li>
</ul>
</li>
<li>
<b><a class="el" href="namespace_utils.html" title="Utils provides utility functions.">Utils</a></b>: Utilities used by SL and CV </li>
<li>
<b>Externals</b>: External dependencies </li>
</ul>
<p><img src="../images/SLProject-App-Structure.png" alt="" width="30%" class="inline"/> </p>
<p><br  />
<br  />
 </p>
<h1><a class="anchor" id="diagram"></a>
Class Diagram</h1>
<p>The following class diagram gives you an overview of the major classes with its important variables and methods: </p><ul>
<li>
The <b>grey boxes</b> on top contain the application code that depend on the OS and do the GUI, the scene assembly and the video processing. </li>
<li>
The <b>light blue classes</b> are the central classes with the top-level instances of SLApplication and <a class="el" href="class_s_l_input_manager.html" title="SLInputManager. manages system input and custom input devices.">SLInputManager</a>. The core classes for the scene are <a class="el" href="class_s_l_scene.html" title="The SLScene class represents the top level instance holding the scene structure.">SLScene</a> and <a class="el" href="class_s_l_scene_view.html" title="SceneView class represents a dynamic real time 3D view onto the scene.">SLSceneView</a>. </li>
<li>
The <b>dark blue classes</b> are the alternative renderers for ray tracing and path tracing. </li>
<li>
The <b>yellow classes</b> define the materials that are responsible for the visual appearances of the mesh objects. </li>
<li>
The <b>green classes</b> build the scene graph that defines the spacial structure of the visible objects. </li>
<li>
The <b>pink classes</b> define a single triangulated mesh object. </li>
<li>
The <b>violet classes</b> encapsulate all OpenGL vertex array object and buffer objects. </li>
<li>
The <b>red classes</b> build the animation framework. </li>
<li>
The <b>orange classes</b> encapsulate the video, image and AR tracking functionality using OpenCV. CV classes are independent from all SL classes. Only <a class="el" href="class_s_l_g_l_texture.html" title="Texture object for OpenGL texturing.">SLGLTexture</a> uses <a class="el" href="class_c_v_image.html" title="OpenCV image class with the same interface as the former SLImage class.">CVImage</a> for its texture images. </li>
<li>
The <b>red classes</b> build the animation framework. </li>
<li>
The <b>white classes</b> are low level classes for the math. Some of them are within the namespace <a class="el" href="namespace_utils.html" title="Utils provides utility functions.">Utils</a>. </li>
<li>
The <b>gray boxes</b> at the bottom are the external libraries that are used within the frame work. </li>
</ul>
<p><img src="../images/SLProject_UML_min.svg" alt="" style="pointer-events: none;" width="100%" class="inline"/> </p>
<p><br  />
<br  />
 </p>
<h1><a class="anchor" id="app"></a>
Application Code</h1>
<p>The applications code (grey boxes at the top of the diagram) contains the code for the operating system, the scene definition with SLProject library (SL), the video processing using CV-classes and the UI with ImGUI. In all cases we have the most outer shell of the application that handles the window and the OpenGL context creation and passes the events to a thin C-function interface before it is handled by the C++-framework in the library lib-SLProject. The following OS' are supported and applications are provided for demonstration: </p><ul>
<li>
<b>Windows, Linux and Max OSX</b> applications use the <a href="http://www.glfw.org/">GLFW</a> C-library for the platform independent window and context creation. GLFW is included in the SLProject repository. See the app-Demo-GLFW for demonstration. For all demo apps (desktop and mobile) we use the <a href="https://github.com/ocornut/imgui">ImGUI</a> library for the UI. The UI for the demo apps is implemented in AppDemoGUI. ImGUI is also included in the repository.  </li>
<li>
The <b>Android</b> application starts in JAVA and passes the events with JNI (Java Native Interface) to the C-interface. See the <a href="https://github.com/cpvrlab/SLProject/wiki/Build-for-Android">wiki for build instructions</a> and the app-Demo-Android for demonstration.  </li>
<li>
On <b>Apple iOS</b> Devices the application starts in ObjectiveC before it passes the events to the C-interface. See the <a href="https://github.com/cpvrlab/SLProject/wiki/Build-for-Apple-iOS">wiki for build instructions</a> and the app-Demo-iOS for demonstration.  </li>
<li>
You could in fact use any GUI library on any OS that can create OpenGL contexts. Other alternatives could be e.g. <a href="https://www.qt.io/">Qt</a>, <a href="http://freeglut.sourceforge.net/">freeglut</a>, <a href="http://www.fltk.org/index.php">FLTK</a>, <a href="http://www.wxwidgets.org/">wxWidgets</a>, <a href="http://www.nanapro.org/en-us/">Nana</a> or <a href="http://www.juce.com/">Juce</a>.  </li>
<li>
SLInterface.h and SLInterface.cpp define the C-Interface of the SLProject library. We use a C-interface because this type can be called from any higher level language. The SLInterface talks only to the SLApplication, <a class="el" href="class_s_l_scene.html" title="The SLScene class represents the top level instance holding the scene structure.">SLScene</a> and <a class="el" href="class_s_l_scene_view.html" title="SceneView class represents a dynamic real time 3D view onto the scene.">SLSceneView</a> classes.  </li>
</ul>
<h1><a class="anchor" id="central"></a>
Central Classes</h1>
<p>The light blue classes form the center of the SLProject framework: </p><ul>
<li>
The SLApplication holds static instances of top-level items such as the input manager, the scene pointer and the device rotation and location information.  </li>
<li>
<a class="el" href="class_s_l_input_manager.html" title="SLInputManager. manages system input and custom input devices.">SLInputManager</a> collects all user events from the mouse and keyboard as well as from additional input devices such as a LeapMotion or Kinect sensor.  </li>
<li>
<a class="el" href="class_s_l_scene.html" title="The SLScene class represents the top level instance holding the scene structure.">SLScene</a> is the top-level class of the framework that represents the scene with its properties. The scene content is created in <a class="el" href="class_s_l_scene.html#ad64c907ecd28bfb20fcbfdaea8c1f0e3" title="C-Callback for scene load.">SLScene::onLoad</a>. It also holds one or more pointers to <a class="el" href="class_s_l_scene_view.html" title="SceneView class represents a dynamic real time 3D view onto the scene.">SLSceneView</a> instances.  </li>
<li>
<a class="el" href="class_s_l_scene_view.html" title="SceneView class represents a dynamic real time 3D view onto the scene.">SLSceneView</a> represents a dynamic real time 3D view onto the scene. A scene can be shown in multiple sceneviews as demonstrated in the app-Viewer-Qt application. A sceneview receives all events (keyboard, mouse etc.) from the GUI via the <a class="el" href="class_s_l_input_manager.html" title="SLInputManager. manages system input and custom input devices.">SLInputManager</a>.  </li>
</ul>
<h1><a class="anchor" id="node"></a>
Scenegraph Classes</h1>
<p><a class="el" href="class_s_l_node.html" title="SLNode represents a node in a hierarchical scene graph.">SLNode</a> is the major building block for the the scenegraph structure (green classes) and can have 0-N children nodes and 0-N triangle meshes. A node can be transformed (translated, rotated and scaled) in 3D-space. </p><ul>
<li>
<a class="el" href="class_s_l_light_direct.html" title="SLLightDirect class for a directional light source.">SLLightDirect</a>, <a class="el" href="class_s_l_light_spot.html" title="SLLightSpot class for a spot light source.">SLLightSpot</a> and <a class="el" href="class_s_l_light_rect.html" title="Light node class for a rectangular light source.">SLLightRect</a> are from <a class="el" href="class_s_l_node.html" title="SLNode represents a node in a hierarchical scene graph.">SLNode</a> derived and define lights that can be placed and directed in space.  </li>
<li>
<a class="el" href="class_s_l_camera.html" title="Active or visible camera node class.">SLCamera</a> that defines the view to the scene. The scene can have multiple cameras but only one can be active for the scene view.  </li>
</ul>
<h1><a class="anchor" id="mesh"></a>
Mesh Classes</h1>
<p><a class="el" href="class_s_l_mesh.html" title="An SLMesh object is a triangulated mesh that is drawn with one draw call.">SLMesh</a> is the base class for triangulated or wire framed meshes (pink classes). A mesh is rendered with a material defined in <a class="el" href="class_s_l_material.html" title="Defines a standard CG material with textures and a shader program.">SLMaterial</a>. A mesh has all the vertex attributes such as position, normals, texture coordinates. The triangles are defined by indexes into the vertex attribute arrays. A mesh has an instance of <a class="el" href="class_s_l_g_l_vertex_array.html" title="SLGLVertexArray encapsulates the core OpenGL drawing.">SLGLVertexArray</a> that does all the OpenGL drawing. This vertex array object (VAO) stores all attributes in either a float or half float vertex attribute buffer (<a class="el" href="class_s_l_g_l_vertex_buffer.html" title="SLGLVertexBuffer encapsulates an OpenGL buffer for vertex attributes.">SLGLVertexBuffer</a>) that is generated in the memory of the GPU. The attribute data on the client side is not deleted because it is used for ray tracing. </p><ul>
<li>
<a class="el" href="class_s_l_revolver.html" title="SLRevolver is an SLMesh object built out of revolving points.">SLRevolver</a>, <a class="el" href="class_s_l_sphere.html" title="SLSphere creates a sphere mesh based on SLSpheric w. 180 deg polar angle.">SLSphere</a>, <a class="el" href="class_s_l_cylinder.html" title="SLCylinder is creates sphere mesh based on its SLRevolver methods.">SLCylinder</a>, <a class="el" href="class_s_l_cone.html" title="SLCone creates a cone mesh based on SLRevolver.">SLCone</a>, <a class="el" href="class_s_l_box.html" title="Axis aligned box mesh.">SLBox</a>, <a class="el" href="class_s_l_polygon.html" title="SLPolygon creates a convex polyon mesh.">SLPolygon</a> and <a class="el" href="class_s_l_rectangle.html" title="SLRectangle creates a rectangular mesh with a certain resolution.">SLRectangle</a> are all inheritants from <a class="el" href="class_s_l_mesh.html" title="An SLMesh object is a triangulated mesh that is drawn with one draw call.">SLMesh</a> and represent the according platonic shapes.  </li>
<li>
<a class="el" href="class_s_l_a_a_b_box.html" title="Defines an axis aligned bounding box.">SLAABBox</a> and <a class="el" href="class_s_l_uniform_grid.html" title="SLUniformGrid is an acceleration structure the uniformly subdivides space.">SLUniformGrid</a> implement the space partitioning. Every <a class="el" href="class_s_l_node.html" title="SLNode represents a node in a hierarchical scene graph.">SLNode</a> has an axis aligned AABB that is used for fast frustum culling and ray shooting.  </li>
</ul>
<h1><a class="anchor" id="vao"></a>
VertexArray Classes</h1>
<p><a class="el" href="class_s_l_g_l_vertex_array.html" title="SLGLVertexArray encapsulates the core OpenGL drawing.">SLGLVertexArray</a> and <a class="el" href="class_s_l_g_l_vertex_buffer.html" title="SLGLVertexBuffer encapsulates an OpenGL buffer for vertex attributes.">SLGLVertexBuffer</a> encapsulate all OpenGL buffer stuff and provides the core drawing functionality with OpenGL. </p>
<h1><a class="anchor" id="material"></a>
Material Classes</h1>
<p><a class="el" href="class_s_l_material.html" title="Defines a standard CG material with textures and a shader program.">SLMaterial</a> is the core of the yellow classes that define the appearance of a mesh. A material can have one or more texture images and is rendered with a specific shader program written in the OpenGL shading language (GLSL). </p><ul>
<li>
<a class="el" href="class_s_l_g_l_texture.html" title="Texture object for OpenGL texturing.">SLGLTexture</a> defines a texture image with filtering parameters.  </li>
<li>
<a class="el" href="class_s_l_g_l_program.html" title="Encapsulation of an OpenGL shader program object.">SLGLProgram</a> defines a shader program with at least one vertex and one fragment shader program.  </li>
<li>
<a class="el" href="class_s_l_g_l_shader.html" title="Encapsulation of an OpenGL shader object.">SLGLShader</a> defines a vertex or fragment shader where the source code is read from a file.  </li>
<li>
All OpenGL code is restricted to the classes beginning with SLGL. (<a class="el" href="class_s_l_g_l_state.html" title="Singleton class holding all OpenGL states.">SLGLState</a>, <a class="el" href="class_s_l_g_l_texture.html" title="Texture object for OpenGL texturing.">SLGLTexture</a>, <a class="el" href="class_s_l_g_l_shader.html" title="Encapsulation of an OpenGL shader object.">SLGLShader</a>, <a class="el" href="class_s_l_g_l_program.html" title="Encapsulation of an OpenGL shader program object.">SLGLProgram</a>, <a class="el" href="class_s_l_g_l_vertex_array.html" title="SLGLVertexArray encapsulates the core OpenGL drawing.">SLGLVertexArray</a> and <a class="el" href="class_s_l_g_l_vertex_buffer.html" title="SLGLVertexBuffer encapsulates an OpenGL buffer for vertex attributes.">SLGLVertexBuffer</a>.)  </li>
<li>
The linear algebra math is implemented in the classes <a class="el" href="class_s_l_mat3.html" title="3x3 matrix template class">SLMat3</a>, <a class="el" href="class_s_l_mat4.html" title="4x4 matrix template class">SLMat4</a>, <a class="el" href="class_s_l_vec3.html" title="3D vector template class for standard 3D vector algebra.">SLVec3</a>, <a class="el" href="class_s_l_vec4.html" title="4D vector template class for standard 4D vector algebra.">SLVec4</a> and <a class="el" href="class_s_l_quat4.html" title="Quaternion class for angle-axis rotation representation.">SLQuat4</a>.  </li>
</ul>
<h1><a class="anchor" id="animation"></a>
Animation Classes</h1>
<p>The red animation classes provide the functionality for simple node animations or skeletal animations. </p><ul>
<li>
<a class="el" href="class_s_l_anim_manager.html" title="SLAnimManager is the central class for all animation handling.">SLAnimManager</a>: A single instance of this class is held by the <a class="el" href="class_s_l_scene.html" title="The SLScene class represents the top level instance holding the scene structure.">SLScene</a> instance and is responsible for updating the enabled animations and to manage their life time. It keeps a list of all skeletons and node animations and also holds a list of all animation playback controllers. The update of all animations is done before the rendering of all <a class="el" href="class_s_l_scene_view.html" title="SceneView class represents a dynamic real time 3D view onto the scene.">SLSceneView</a> instances.  </li>
<li>
<a class="el" href="class_s_l_anim_playback.html" title="Manages the playback of an SLAnimation.">SLAnimPlayback</a> manages the playback state and the local time of an <a class="el" href="class_s_l_animation.html" title="SLAnimation is the base container for all animation data.">SLAnimation</a>. It manages the way the time advances and how the animation loops. It has all functionality to play, pause, stop, enable, speed up and slow down a playback. A list of all <a class="el" href="class_s_l_anim_playback.html" title="Manages the playback of an SLAnimation.">SLAnimPlayback</a> instances is held by the <a class="el" href="class_s_l_anim_manager.html" title="SLAnimManager is the central class for all animation handling.">SLAnimManager</a>.  </li>
<li>
<a class="el" href="class_s_l_animation.html" title="SLAnimation is the base container for all animation data.">SLAnimation</a> is a container for multiple <a class="el" href="class_s_l_anim_track.html" title="Abstract base class for SLAnimationTracks providing time and keyframe functions.">SLAnimTrack</a> that build an animation. E.g. a walk animation would consist of all the <a class="el" href="class_s_l_anim_track.html" title="Abstract base class for SLAnimationTracks providing time and keyframe functions.">SLAnimTrack</a> that make a <a class="el" href="class_s_l_skeleton.html" title="SLSkeleton keeps track of a skeletons joints and animations.">SLSkeleton</a> walk. It also knows the length of the animation.  </li>
<li>
<a class="el" href="class_s_l_anim_track.html" title="Abstract base class for SLAnimationTracks providing time and keyframe functions.">SLAnimTrack</a> and <a class="el" href="class_s_l_node_anim_track.html" title="Specialized animation track for node animations.">SLNodeAnimTrack</a>: An animation track is a track that affects a single <a class="el" href="class_s_l_node.html" title="SLNode represents a node in a hierarchical scene graph.">SLNode</a> or an <a class="el" href="class_s_l_joint.html" title="Specialized SLNode that represents a single joint (or bone) in a skeleton.">SLJoint</a> of an <a class="el" href="class_s_l_skeleton.html" title="SLSkeleton keeps track of a skeletons joints and animations.">SLSkeleton</a> by interpolating its transform. It holds therefore a list of SLKeyframe. For a smooth motion it can interpolate the transform at a given time between two neighbouring SLKeyframe.  </li>
<li>
SLKeyframe and <a class="el" href="class_s_l_transform_keyframe.html" title="SLTransformKeyframe is a specialized SLKeyframe for node transformations.">SLTransformKeyframe</a> define a transform at a certain time on an <a class="el" href="class_s_l_anim_track.html" title="Abstract base class for SLAnimationTracks providing time and keyframe functions.">SLAnimTrack</a>.  </li>
<li>
<a class="el" href="class_s_l_skeleton.html" title="SLSkeleton keeps track of a skeletons joints and animations.">SLSkeleton</a>: A skeleton is used to animate a hierarchical object like a human figure. An <a class="el" href="class_s_l_skeleton.html" title="SLSkeleton keeps track of a skeletons joints and animations.">SLSkeleton</a> keeps track of its bones (SLJoints) in a tree structure and points with _root to the root node of the skeleton hierarchy. An <a class="el" href="class_s_l_skeleton.html" title="SLSkeleton keeps track of a skeletons joints and animations.">SLSkeleton</a> is not actively transforming any <a class="el" href="class_s_l_node.html" title="SLNode represents a node in a hierarchical scene graph.">SLNode</a> in the scene graph. It just keeps track of its transformed <a class="el" href="class_s_l_joint.html" title="Specialized SLNode that represents a single joint (or bone) in a skeleton.">SLJoint</a>. A mesh that is associated with a skeleton transforms all its vertices every frame by the joint weights (Jw). Every vertex of a mesh has weights for up to four joints by which it can be influenced.  </li>
<li>
<a class="el" href="class_s_l_joint.html" title="Specialized SLNode that represents a single joint (or bone) in a skeleton.">SLJoint</a> is a specialised <a class="el" href="class_s_l_node.html" title="SLNode represents a node in a hierarchical scene graph.">SLNode</a> that represents a single joint (or bone) in a skeleton The main addition of <a class="el" href="class_s_l_joint.html" title="Specialized SLNode that represents a single joint (or bone) in a skeleton.">SLJoint</a> to the base <a class="el" href="class_s_l_node.html" title="SLNode represents a node in a hierarchical scene graph.">SLNode</a> is the offset matrix which is the inverse transformation of the joint's binding pose in mesh space. It is used to transform the vertices of a rigged <a class="el" href="class_s_l_mesh.html" title="An SLMesh object is a triangulated mesh that is drawn with one draw call.">SLMesh</a> to the origin of the joint to be able to manipulate them in the joint's local space.  </li>
</ul>
<h1><a class="anchor" id="imageprocessing"></a>
Image and Video Processing Classes</h1>
<p>The orange classes provide the functionality for video and image processing using the OpenCV framework. The SLProject framework can now process the images from attached live video cameras. This works via OpenCV on desktop OS as well as on iOS and Android. The live video image is constantly fed into an OpenGL texture that can be used as a texture on an objects material or as the scenes background. With the live video in the background you can create augmented reality (AR) applications. Examples can be found in the demo application under Load Scene &gt; Using Video &gt; Track Chessboard or Track AruCo. </p><ul>
<li>
<a class="el" href="class_c_v_image.html" title="OpenCV image class with the same interface as the former SLImage class.">CVImage</a>: Replaces the deprecated SLImage class and provides all for loading, saving and converting images. Internally it stores the image in a cv::Mat instance. <br  />
  </li>
<li>
CVCapture: Holds static images from the OpenCV video capture or from an external (iOS and Android) video capture service. There is an CVCapture::lastFrame and an CVCapture::lastFrameGray with the gray level version of the last capture video frame.  </li>
<li>
<a class="el" href="class_c_v_calibration.html" title="Live video camera calibration class with OpenCV an OpenCV calibration.">CVCalibration</a> holds all functionality to calibrate the video camera. A classic chessboard pattern is used for calibration. In the demo application a special scene is provided for the calibration (Preferences &gt; Video &gt; Calibrate Camera).  </li>
<li>
<a class="el" href="class_c_v_tracked.html" title="CVTracked is the pure virtual base class for tracking features in video.">CVTracked</a> is the base class for tracking classes. The scene can have multiple trackers. A tracker is associated with a Node. When the object to be tracked is found, it controls the nodes transform. If the associated node is the scenes active camera a classic augmented reality application can be generated. <br  />
  </li>
<li>
<a class="el" href="class_c_v_tracked_chessboard.html" title="OpenCV chessboard tracker class derived from CVTracked.">CVTrackedChessboard</a> tracks the same chessboard that is used for the camera calibration.  </li>
<li>
<a class="el" href="class_c_v_tracked_aruco.html" title="OpenCV ArUco marker tracker class derived from CVTracked.">CVTrackedAruco</a> tracks special markers called AruCo markers. These markers are optimal in tracking performance and stability. <br  />
  </li>
<li>
<a class="el" href="class_c_v_tracked_features.html" title="CVTrackedFeatures is the main part of the AR Christoffelturm scene.">CVTrackedFeatures</a> tracks any 2D features. Supported are any feature detectors and descriptors that are provided by OpenCV. In addition we include the enhanced ORB feature detector developed by <a href="https://github.com/raulmur/ORB_SLAM2/">Raul Mur</a>  </li>
</ul>
<p>Authors: <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'cu'+'s.h'+'ud'+'rit'+'sc'+'h@b'+'fh'+'.ch'; return false;">marcu<span style="display: none;">.nosp@m.</span>s.hu<span style="display: none;">.nosp@m.</span>drits<span style="display: none;">.nosp@m.</span>ch@b<span style="display: none;">.nosp@m.</span>fh.ch</a><br  />
 Date: February 2018<br  />
 Copyright (c): 2002-2018 Marcus Hudritsch, Kirchrain 18, 2572 Sutz, Switzerland </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Sep 18 2020 14:31:38 for SLProject by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
